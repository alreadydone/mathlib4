/-
Copyright (c) 2025 Junyan Xu. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Junyan Xu
-/
import Mathlib.Topology.IsLocalHomeomorph
import Mathlib.Topology.Sheaves.LocalPredicate

/-!
# √âtale spaces of local predicates and presheaves

This file establishes the connection between `TopCat.LocalPredicate` on a family of types
over a base space `B` (think of a set of sections over `B`) and local homeomorphisms to `B`
(i.e., √©tale spaces over `B`).

In the file `Mathlib.Topology.Sheaves.Sheafify`, the connection between `TopCat.LocalPredicate`
and (pre)sheaves has been established. It combines with this file to establish the connection
between sheaves and √©tale spaces.

## Main definitions


-/

open CategoryTheory TopologicalSpace Opposite Set

universe u v

namespace TopCat

variable {B : TopCat.{u}} {F : B ‚Üí Type v}

set_option linter.unusedVariables false in
/-- The underlying type of the √©tale space associated to a predicate on sections of a type family
is simply the sigma type. -/
def EtaleSpace (pred : Œ† ‚¶ÉU : Opens B‚¶Ñ, ((Œ† b : U, F b) ‚Üí Prop)) : Type _ := Œ£ b, F b

namespace EtaleSpace

variable {pred : Œ† ‚¶ÉU : Opens B‚¶Ñ, ((Œ† b : U, F b) ‚Üí Prop)}

/-- Constructor for points in the √©tale space. -/
@[simps] def mk {b : B} (x : F b) : EtaleSpace pred := ‚ü®b, x‚ü©

/-- The √©tale space is endowed with the strongest topology making every section continuous. -/
instance : TopologicalSpace (EtaleSpace pred) :=
  ‚®Ü (U : Opens B) (s : Œ† b : U, F b) (_ : pred s), coinduced (mk <| s ¬∑) inferInstance

lemma isOpen_iff {V : Set (EtaleSpace pred)} :
    IsOpen V ‚Üî
    ‚àÄ (U : Opens B) (s : Œ† b : U, F b), pred s ‚Üí IsOpen ((mk <| s ¬∑) ‚Åª¬π' V) := by
  simp_rw [isOpen_iSup_iff, isOpen_coinduced]

lemma continuous_dom_iff {X} [TopologicalSpace X] {f : EtaleSpace pred ‚Üí X} :
    Continuous f ‚Üî
    ‚àÄ (U : Opens B) (s : Œ† b : U, F b), pred s ‚Üí Continuous (f <| mk <| s ¬∑) := by
  simp_rw [continuous_def, isOpen_iff, preimage_preimage,
    ‚Üê forall_comm (Œ± := Set X), ‚Üê forall_comm (Œ± := IsOpen _)]

variable (pred) in
/-- The projection from the √©tale space down to the base is continuous. -/
def proj : C(EtaleSpace pred, B) where
  toFun := Sigma.fst
  continuous_toFun := continuous_dom_iff.mpr fun _ _ _ ‚Ü¶ continuous_subtype_val

section Section

variable {U : Opens B} {s : Œ† b : U, F b} (hs : pred s)
include hs

lemma continuous_section : Continuous fun b ‚Ü¶ (mk (s b) : EtaleSpace pred) :=
  continuous_iff_coinduced_le.mpr (le_iSup‚ÇÇ_of_le U s <| le_iSup_of_le hs le_rfl)

/-- The domain of any section is homeomorphic to its range. -/
def homeomorphRangeSection : U ‚âÉ‚Çú range fun b ‚Ü¶ (mk (s b) : EtaleSpace pred) where
  toFun b := ‚ü®_, b, rfl‚ü©
  invFun x := ‚ü®proj pred x, by obtain ‚ü®_, b, rfl‚ü© := x; exact b.2‚ü©
  left_inv _ := rfl
  right_inv := by rintro ‚ü®_, _, rfl‚ü©; rfl
  continuous_toFun := (continuous_section hs).subtype_mk _
  continuous_invFun := ((proj pred).continuous.comp continuous_subtype_val).subtype_mk <| by
    rintro ‚ü®_, b, rfl‚ü©; exact b.2

theorem isOpen_range_section (inj : ‚àÄ b, IsStalkInj pred b) :
    IsOpen (range fun b ‚Ü¶ (mk (s b) : EtaleSpace pred)) :=
  isOpen_iff.mpr fun V t ht ‚Ü¶ isOpen_iff_mem_nhds.mpr fun ‚ü®v, hv‚ü© ‚ü®‚ü®u, hu‚ü©, he‚ü© ‚Ü¶ by
    cases congr($he.1)
    have ‚ü®W, iU, iV, eq‚ü© := inj v ‚ü®U, hu‚ü© ‚ü®V, hv‚ü© _ _ hs ht congr($he.2)
    exact Filter.mem_of_superset ((W.1.2.preimage continuous_subtype_val).mem_nhds W.2)
      fun v hv ‚Ü¶ ‚ü®‚ü®v, iU.le hv‚ü©, congr(mk $(eq ‚ü®v, hv‚ü©))‚ü©

open Topology

theorem isOpenEmbedding_section (inj : ‚àÄ b, IsStalkInj pred b) :
    IsOpenEmbedding fun b ‚Ü¶ (mk (s b) : EtaleSpace pred) := by
  rw [isOpenEmbedding_iff, isEmbedding_iff, and_assoc]
  exact ‚ü®.of_comp (continuous_section hs) (proj pred).continuous .subtypeVal,
    fun _ _ eq ‚Ü¶ Subtype.ext congr(proj pred $eq), isOpen_range_section hs inj‚ü©

theorem isOpenEmbedding_restrict_proj :
    IsOpenEmbedding ((range (mk <| s ¬∑)).restrict (proj pred)) :=
  U.2.isOpenEmbedding_subtypeVal.comp (homeomorphRangeSection hs).symm.isOpenEmbedding

omit hs

theorem isTopologicalBasis {P : PrelocalPredicate F}
    (inj : ‚àÄ b, IsStalkInj P.pred b) (surj : ‚àÄ b, IsStalkSurj P.pred b) :
    IsTopologicalBasis {V : Set (EtaleSpace P.pred) |
      ‚àÉ (U : Opens B) (s : Œ† b : U, F b), P.pred s ‚àß V = range (mk <| s ¬∑)} :=
  isTopologicalBasis_of_isOpen_of_nhds
      (by rintro _ ‚ü®U, s, hs, rfl‚ü©; exact isOpen_range_section hs inj) fun ‚ü®b, x‚ü© V hx hV ‚Ü¶ by
    have ‚ü®U, s, hs, eq‚ü© := surj _ x
    let W : Opens B := ‚ü®_, U.1.2.isOpenMap_subtype_val _ (isOpen_iff.mp hV _ s hs)‚ü©
    refine ‚ü®_, ‚ü®W, _, P.res image_val_subset.hom s hs, rfl‚ü©,
      ‚ü®‚ü®b, ‚ü®b, U.2‚ü©, by rwa [mem_preimage, eq], rfl‚ü©, congr(mk $eq)‚ü©, ?_‚ü©
    rintro _ ‚ü®‚ü®_, b, hb, rfl‚ü©, rfl‚ü©
    exact hb

theorem continuous_cod_iff (inj : ‚àÄ b, IsStalkInj pred b) (surj : ‚àÄ b, IsStalkSurj pred b)
    {X} [TopologicalSpace X] {f : X ‚Üí EtaleSpace pred} :
    Continuous f ‚Üî Continuous (proj pred ‚àò f) ‚àß ‚àÄ x, ‚àÉ (U : OpenNhds (f x).1) (s : Œ† b : U.1, F b),
      pred s ‚àß ‚àÉ V ‚àà ùìù x, ‚àÄ x' (h' : (f x').1 ‚àà U.1), x' ‚àà V ‚Üí s ‚ü®_, h'‚ü© = (f x').2 := by
  refine ‚ü®fun h ‚Ü¶ ‚ü®(proj pred).continuous.comp h, fun x ‚Ü¶ ?_‚ü©,
    fun ‚ü®cont, eq‚ü© ‚Ü¶ continuous_iff_continuousAt.mpr fun x ‚Ü¶ ?_‚ü©
  ¬∑ have ‚ü®U, s, hs, eq‚ü© := surj _ (f x).2
    refine ‚ü®U, s, hs, _, ((isOpen_range_section hs inj).preimage h).mem_nhds <|
      by exact ‚ü®_, congr(mk $eq)‚ü©, fun x hx ‚ü®b, eq‚ü© ‚Ü¶ ?_‚ü©
    set y := f x with hy; clear_value y
    have : s ‚ü®y.1, hx‚ü© = y.2 := by cases eq; rfl
    cases hy; exact this
  ¬∑ have ‚ü®U, s, hs, V, hV, eq‚ü© := eq x
    exact (continuousOn_iff_continuous_restrict.mpr <| ((continuous_section hs).comp
      (f := (‚ü®_, ¬∑.2.1‚ü©)) <| (cont.comp continuous_subtype_val).subtype_mk _).congr
        fun x ‚Ü¶ by exact congr(mk $(eq x x.2.1 x.2.2))).continuousAt
      (Filter.inter_mem (cont.continuousAt.preimage_mem_nhds (U.1.2.mem_nhds U.2)) hV)

theorem continuous_section_iff {P : PrelocalPredicate F}
    (inj : ‚àÄ b, IsStalkInj P.pred b) (surj : ‚àÄ b, IsStalkSurj P.pred b) :
    Continuous (fun b ‚Ü¶ (mk (s b) : EtaleSpace P.pred)) ‚Üî P.sheafify.pred s := by
  rw [continuous_cod_iff inj surj, and_iff_right (by exact continuous_subtype_val)]
  constructor <;> intro h x
  ¬∑ have ‚ü®W, t, ht, V, hV, eq‚ü© := h x
    have ‚ü®V', hV', hV, hxV‚ü© := mem_nhds_iff.mp hV
    refine ‚ü®W.1 ‚äì ‚ü®_, U.2.isOpenMap_subtype_val _ hV‚ü©,
      ‚ü®W.2, _, hxV, rfl‚ü©, Opens.infLERight .. ‚â´ image_val_subset.hom, ?_‚ü©
    convert ‚Üê P.res (Opens.infLELeft ..) _ ht with ‚ü®_, hW, x, hxV, rfl‚ü©
    exact eq _ _ (hV' hxV)
  ¬∑ have ‚ü®V, hV, i, hs‚ü© := h x
    exact ‚ü®‚ü®V, hV‚ü©, _, hs, _, (V.2.preimage continuous_subtype_val).mem_nhds hV, fun _ _ _ ‚Ü¶ rfl‚ü©

end Section

theorem isLocalHomeomorph_proj (inj : ‚àÄ b, IsStalkInj pred b) (surj : ‚àÄ b, IsStalkSurj pred b) :
    IsLocalHomeomorph (proj pred) :=
  isLocalHomeomorph_iff_isOpenEmbedding_restrict.mpr fun x ‚Ü¶
    have ‚ü®_U, _s, hs, eq‚ü© := surj _ x.2
    ‚ü®_, (isOpen_range_section hs inj).mem_nhds ‚ü®_, congr(mk $eq)‚ü©, isOpenEmbedding_restrict_proj hs‚ü©



-- a presheaf is a sheaf iff its prelocal predicate is local ..

variable (F)


variable (X : Type*) [TopologicalSpace X] (p : C(X, B))

def adjunction : {f : C(F.EtaleSpace, X) // p.comp f = proj F} ‚âÉ
    {f : (Œ† U, F.obj U ‚Üí (sheafOfSections p).1.obj U) //
      ‚àÄ U V (i : U ‚ü∂ V), (sheafOfSections p).1.map i ‚àò f U = f V ‚àò F.map i} where
  toFun := _
  invFun := _
  left_inv := _
  right_inv := _

-- the opens in the etale space of a local predicate are exactly images of germMap .. no, only if proj is injective on the open

-- many functors!
-- Presheaf B -EtaleSpace‚Üí LocalHomeo/B -sections‚Üí Sheaf B : composition NatIso to sheafification ..
-- Presheaf -sheafification‚Üí Sheaf -forget‚Üí Presheaf .. adjunction such that one composition is iso to identity ..





variable {X : Type*} [TopologicalSpace X] {B : TopCat}

/-- The continuous sections of a (not necessarily continuous) function between two
  topological spaces form a sheaf over the base space. -/
def sheafOfSections (p : X ‚Üí B) : B.Sheaf (Type _) :=
  B.subsheafToTypes <| (B.continuousLocal X).and <| B.isSection p

/-- The stalks of the sheaf of sections are in bijections with the fibers. -/
def stalkSectionsEquivFiber (p : X ‚Üí B) (b : B) :
    (sheafOfSections p).presheaf.stalk b ‚âÉ p ‚Åª¬π' {b} where
  toFun := ‚ü®_, _‚ü©
  invFun := _
  left_inv := _
  right_inv := _


-- stalks of this sheaf is equiv to fibers of p?
-- should be the case since sheafification preserves stalks

-- Right adjoint is fully faithful iff the counit is an isomorphism  ...
-- "reflection", coreflection -- reflective
-- idempotent adjunction: reflective, coreflective
-- monadic adjunction

-- sections can be considered to be morphisms between certain objects of Top/B .. Yoneda?
-- use open set in B as "test objects"


def EtaleSpaceOver (B : TopCat) : Type _ :=
  ObjectProperty.FullSubcategory fun f : Over B ‚Ü¶ IsLocalHomeomorph f.hom
